{"ast":null,"code":"/**\r\n * Simple markdown to HTML converter\r\n * Converts common markdown syntax to HTML tags\r\n * @param {string} markdown - The markdown text to convert\r\n * @returns {string} - The converted HTML\r\n */\nexport const markdownToHtml = markdown => {\n  if (!markdown) return '';\n  let html = markdown;\n\n  // Convert headers\n  html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');\n  html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');\n  html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');\n\n  // Convert bold text\n  html = html.replace(/\\*\\*(.*)\\*\\*/gim, '<strong>$1</strong>');\n\n  // Convert italic text\n  html = html.replace(/\\*(.*)\\*/gim, '<em>$1</em>');\n\n  // Convert unordered lists\n  html = html.replace(/^\\- (.*$)/gim, '<li>$1</li>');\n  html = html.replace(/(<li>.*<\\/li>)/gim, '<ul>$1</ul>');\n\n  // Convert ordered lists\n  html = html.replace(/^\\d+\\. (.*$)/gim, '<li>$1</li>');\n  html = html.replace(/(<li>.*<\\/li>)/gim, '<ol>$1</ol>');\n\n  // Convert line breaks to paragraphs\n  html = html.replace(/\\n\\n/g, '</p><p>');\n  html = html.replace(/^(.*)$/gim, '<p>$1</p>');\n\n  // Clean up empty paragraphs\n  html = html.replace(/<p><\\/p>/g, '');\n\n  // Clean up nested paragraphs\n  html = html.replace(/<p><p>/g, '<p>');\n  html = html.replace(/<\\/p><\\/p>/g, '</p>');\n  return html;\n};\n\n/**\r\n * Plain text to HTML converter\r\n * Converts plain text with line breaks to HTML paragraphs\r\n * @param {string} text - The plain text to convert\r\n * @returns {string} - The converted HTML\r\n */\nexport const plainTextToHtml = text => {\n  if (!text) return '';\n\n  // Escape HTML characters\n  let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\n  // Convert line breaks to paragraphs\n  html = html.replace(/\\n\\n/g, '</p><p>');\n  html = html.replace(/\\n/g, '<br>');\n  html = `<p>${html}</p>`;\n\n  // Clean up empty paragraphs\n  html = html.replace(/<p><\\/p>/g, '');\n  return html;\n};\n\n/**\r\n * Detect if text is markdown or plain text and convert accordingly\r\n * @param {string} text - The text to convert\r\n * @returns {string} - The converted HTML\r\n */\nexport const convertToHtml = text => {\n  if (!text) return '';\n\n  // Simple heuristic to detect markdown\n  const markdownPatterns = [/^#{1,6}\\s/,\n  // Headers\n  /\\*\\*.*\\*\\*/,\n  // Bold\n  /\\*.*\\*/,\n  // Italic\n  /^\\- .*/,\n  // Unordered lists\n  /^\\d+\\..*/ // Ordered lists\n  ];\n  const isMarkdown = markdownPatterns.some(pattern => pattern.test(text));\n  if (isMarkdown) {\n    return markdownToHtml(text);\n  } else {\n    return plainTextToHtml(text);\n  }\n};\nexport default {\n  markdownToHtml,\n  plainTextToHtml,\n  convertToHtml\n};","map":{"version":3,"names":["markdownToHtml","markdown","html","replace","plainTextToHtml","text","convertToHtml","markdownPatterns","isMarkdown","some","pattern","test"],"sources":["D:/SRC/XAMPP/htdocs/sites/UI/article-page-v07/src/utils/markdown.js"],"sourcesContent":["/**\r\n * Simple markdown to HTML converter\r\n * Converts common markdown syntax to HTML tags\r\n * @param {string} markdown - The markdown text to convert\r\n * @returns {string} - The converted HTML\r\n */\r\nexport const markdownToHtml = (markdown) => {\r\n  if (!markdown) return '';\r\n  \r\n  let html = markdown;\r\n  \r\n  // Convert headers\r\n  html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');\r\n  html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');\r\n  html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');\r\n  \r\n  // Convert bold text\r\n  html = html.replace(/\\*\\*(.*)\\*\\*/gim, '<strong>$1</strong>');\r\n  \r\n  // Convert italic text\r\n  html = html.replace(/\\*(.*)\\*/gim, '<em>$1</em>');\r\n  \r\n  // Convert unordered lists\r\n  html = html.replace(/^\\- (.*$)/gim, '<li>$1</li>');\r\n  html = html.replace(/(<li>.*<\\/li>)/gim, '<ul>$1</ul>');\r\n  \r\n  // Convert ordered lists\r\n  html = html.replace(/^\\d+\\. (.*$)/gim, '<li>$1</li>');\r\n  html = html.replace(/(<li>.*<\\/li>)/gim, '<ol>$1</ol>');\r\n  \r\n  // Convert line breaks to paragraphs\r\n  html = html.replace(/\\n\\n/g, '</p><p>');\r\n  html = html.replace(/^(.*)$/gim, '<p>$1</p>');\r\n  \r\n  // Clean up empty paragraphs\r\n  html = html.replace(/<p><\\/p>/g, '');\r\n  \r\n  // Clean up nested paragraphs\r\n  html = html.replace(/<p><p>/g, '<p>');\r\n  html = html.replace(/<\\/p><\\/p>/g, '</p>');\r\n  \r\n  return html;\r\n};\r\n\r\n/**\r\n * Plain text to HTML converter\r\n * Converts plain text with line breaks to HTML paragraphs\r\n * @param {string} text - The plain text to convert\r\n * @returns {string} - The converted HTML\r\n */\r\nexport const plainTextToHtml = (text) => {\r\n  if (!text) return '';\r\n  \r\n  // Escape HTML characters\r\n  let html = text\r\n    .replace(/&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;');\r\n  \r\n  // Convert line breaks to paragraphs\r\n  html = html.replace(/\\n\\n/g, '</p><p>');\r\n  html = html.replace(/\\n/g, '<br>');\r\n  html = `<p>${html}</p>`;\r\n  \r\n  // Clean up empty paragraphs\r\n  html = html.replace(/<p><\\/p>/g, '');\r\n  \r\n  return html;\r\n};\r\n\r\n/**\r\n * Detect if text is markdown or plain text and convert accordingly\r\n * @param {string} text - The text to convert\r\n * @returns {string} - The converted HTML\r\n */\r\nexport const convertToHtml = (text) => {\r\n  if (!text) return '';\r\n  \r\n  // Simple heuristic to detect markdown\r\n  const markdownPatterns = [\r\n    /^#{1,6}\\s/,        // Headers\r\n    /\\*\\*.*\\*\\*/,       // Bold\r\n    /\\*.*\\*/,           // Italic\r\n    /^\\- .*/,           // Unordered lists\r\n    /^\\d+\\..*/          // Ordered lists\r\n  ];\r\n  \r\n  const isMarkdown = markdownPatterns.some(pattern => pattern.test(text));\r\n  \r\n  if (isMarkdown) {\r\n    return markdownToHtml(text);\r\n  } else {\r\n    return plainTextToHtml(text);\r\n  }\r\n};\r\n\r\nexport default { markdownToHtml, plainTextToHtml, convertToHtml };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}